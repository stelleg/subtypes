\documentclass[final]{beamer} 
\mode<presentation>
\usepackage{inconsolata}
\renewcommand*\familydefault{\ttdefault}
\usepackage{dejavu}
\renewcommand*\familydefault{\sfdefault}
\usepackage{lmodern}
\renewcommand\mathfamilydefault{\rmdefault}

\usepackage[T1]{fontenc}
\usepackage{listings}
\lstset{language=Haskell,basicstyle=\ttfamily,xleftmargin=1cm,aboveskip=0.5cm,belowskip=0.5cm}
\usepackage[size=a1]{beamerposter}
\usepackage{verbatim}
\usepackage{tikz}
\usetikzlibrary{arrows, fit, shapes}
\setbeamertemplate{headline}{  
  \leavevmode
  \begin{beamercolorbox}[wd=\paperwidth]{headline}
    \begin{columns}[T]
      \begin{column}{.05\paperwidth}
      \end{column}
      \begin{column}{.7\paperwidth}
        \vskip3cm
        \raggedright
        {\color{red}{{\LARGE{\inserttitle}}\\[1ex]}}
        \vskip0.5cm
        {\color{fg}{\large{\insertauthor}\\[1ex]}}
        %{\color{fg}{\large{\insertinstitute}\\[1ex]}}
      \end{column}
      \begin{column}{.25\paperwidth}
        \begin{center}
          \includegraphics[width=.7\linewidth]{unm}
        \end{center}
        \vskip2cm
      \end{column}
    \end{columns}
  \end{beamercolorbox}

  \begin{beamercolorbox}[wd=\paperwidth]{lower separation line head}
    \rule{0pt}{2pt}
  \end{beamercolorbox}
}

\setbeamertemplate{footline}{}

\mode<all>

\definecolor{red}{RGB}{205,16,65}
\definecolor{grey}{RGB}{109,111,113}

\setbeamerfont{structure}{family=\sffamily}
\setbeamercolor{structure}{fg=red}
\setbeamerfont{normal text}{family=\sffamily}
\setbeamercolor{normal text}{fg=grey,bg=white}

\title{Subtypes for Free!}
\author{George Stelle}
\institute{University of New Mexico}
%\date{\today} 

\begin{document}
\begin{frame}[fragile]
\begin{columns}[t]
\begin{column}{.285\textwidth}

\begin{block}{Introduction}
\vspace{0.5cm}
Some runtime errors are caused by partial functions which are only defined for a
subtype of their input type, e.g. \texttt{head}. We present a simple form of
subtyping that could help Haskell programs avoid some of these run-time errors
by defining total versions of existing partial functions. 
\end{block}
\vspace{1cm}
\begin{block}{Subtypes from Parametric Polymorphism}
\vspace{0.5cm}
Parametric polymorphism implicitly defines subtype lattices. For example, given
the type $\forall a, a \rightarrow a \rightarrow a$, we can derive the following
subtype lattice:
\vspace{0.5cm}
\begin{figure}[!h]
\centering
\begin{tikzpicture}[->, line width=2pt, auto, node distance=4cm]
\node (1) at (5,10) {$\forall a, a \rightarrow a \rightarrow a$};
\node (2) at (0,5) {$\forall a b, a \rightarrow b \rightarrow a$};
\node (3) at (10,5) {$\forall a b, a \rightarrow b \rightarrow b$};
\node (4) at (5,0) {$\forall a b c, a \rightarrow b \rightarrow c$};

\path (2) edge node {} (1)
      (3) edge node {} (1)
      (4) edge node {} (2)
      (4) edge node {} (3);
\end{tikzpicture}
\end{figure}
By subtype relation, we mean the following: a type $\tau$ is a subtype of
another type $\tau'$ iff every value of type $\tau$ is also of type $\tau'$.
\end{block}
\vspace{1cm}
\begin{block}{Unification is Join}
\vspace{0.5cm}
Unification-based type inference has the useful property that it implements the
join (least upper bound) for the lattice described above. Intuitively, this
means that the types inferred will be as specific as possible, given the type
inference algorithm. 
\end{block}
\vspace{1cm}
\begin{block}{Scott Encodings}
\vspace{0.5cm}
Scott encodings are a way of implementing algebraic data types (ADTs) using
lambda terms. They enable the use of subtypes inherent in parametric
polymorphism to implement subtypes for ADTs. For any algebraic data type with
$m$ constructors, implement constructor $C_i$ with $n$ parameters as:

$$C_i x_0 x_1 \cdots x_n = \lambda x_0 x_1 \cdots x_n c_0 c_1 \cdots c_m . c_i x_0 x_1 \cdots x_n$$
\end{block}
\end{column}

\begin{column}{.33\textwidth}
\begin{block}{Example: A Total \texttt{fromJust}}
\vspace{0.5cm}
We begin with the Haskell data type for \texttt{Maybe}:

\begin{verbatim}
  data Maybe a = Nothing
               | Just a
\end{verbatim}

A useful function defined in the Haskell standard library for this type is the
function \texttt{fromJust :: Maybe a -> a}, which fails when applied to
\texttt{Nothing}.

\begin{verbatim}
  fromJust Nothing = error "Maybe.fromJust: Nothing"
\end{verbatim}

We show how to define a total version of \texttt{fromJust}, with type
\texttt{Just a -> a}. To start, we replace \texttt{Maybe} using Scott
encodings:

\begin{verbatim}
  type Maybe a = forall m. m -> (a -> m) -> m 
  type Just a = forall n j. n -> (a -> j) -> j
  just :: a -> Just a
  just a = \n j -> j a
  type Nothing = forall a n j. n -> (a -> j) -> n
  nothing :: Nothing
  nothing = \n j -> n
  type MaybeBottom = forall a n j m. n -> (a -> j) -> m
\end{verbatim}

This definition of \texttt{Maybe} gives us the following subtype lattice:

\begin{figure}[!h]
\centering
\begin{tikzpicture}[->, align=center, line width=2pt, auto, node distance=4cm]
\node (1) at (5,10) {\texttt{Maybe $a$} = \\ $\forall m, m \rightarrow (a
\rightarrow m) \rightarrow m$ \\ \{\texttt{just a}, \texttt{nothing}\}};
\node (2) at (-2,5) {\texttt{Just $a$} = \\ $\forall j n, n \rightarrow (a \rightarrow
j) \rightarrow j$ \\ \{\texttt{just a}\} };
\node (3) at (12,5) {\texttt{Nothing} = \\ $\forall a j n, n \rightarrow (a
\rightarrow j) \rightarrow n$ \\ \{\texttt{nothing}\} };
\node (4) at (5,0) {\texttt{MaybeBottom} = \\ $\forall a j n m, n \rightarrow (a \rightarrow j)
\rightarrow m$ \\ \{\} };

\path (2) edge node {} (1)
      (3) edge node {} (1)
      (4) edge node {} (2)
      (4) edge node {} (3);
\end{tikzpicture}
\end{figure}

The function \texttt{fromJust} in the Haskell standard library is a
\emph{partial} function: it can fail at runtime. We use the above types to
define a total version of \texttt{fromJust} that is type-safe, i.e. cannot
fail at runtime.

\begin{verbatim}
  fromJust :: Just a -> a
  fromJust (Maybe j) = j (undefined::Void) id 
\end{verbatim}

\end{block}

\end{column}

\begin{column}{.285\textwidth}
\begin{block}{Other Examples}
\vspace{0.5cm}
There are number of other potentially useful types expressible and
inferable with this approach:

\begin{verbatim}
   true `and` false :: False
   not . not $ true :: True
   [true, true] :: [True]
   [true, false] :: [Bool]
   head :: Cons a -> a
   tail :: Cons a -> List a
   null nil :: True
   wizard :: DaggerOrStaff -> Wizard
   add :: IntTerm -> IntTerm -> IntTerm
   tnot :: BoolTerm -> BoolTerm 
   eval :: Expr -> Value
\end{verbatim}

\end{block}
\vspace{1cm}
\begin{block}{Related Work}
\vspace{0.5cm}
A brief, incomplete, and mostly wrong hierarchy of tools to define more precise
types. 

\vspace{0.5cm}
\centering
\begin{tikzpicture}[-, line width=1pt, auto, node distance=4cm]

\node (0) at (0,0) {\color{red} Free Subtypes};
\node (1) at (0,3) {Polymorphic Variants};
\node (2) at (0,6) {GADTs / Phantom Types};
\node (3) at (0,9) {Refinement Types};
\node (4) at (0,12) {Dependent Types};

\path (0) edge node {} (1)
      (1) edge node {} (2)
      (2) edge node {} (3)
      (3) edge node {} (4);
\end{tikzpicture}

\end{block}
\vspace{1cm}
\begin{block}{Drawbacks, Limitations, and Future Work}
\vspace{0.5cm}
\begin{itemize}
\item Type composition: Needs impredicative types
\item Type classes: Too polymorphic
\item Recursive subtypes: can't write \verb!head . tail!
\item Potential performance impacts (compile and run time)
\item Ugly: No pattern matching, verbose data type declarations 
\end{itemize}
\vspace{2cm}
\end{block}

\end{column}
\end{columns}
\end{frame}
\end{document}
