\documentclass[]{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={George Stelle and Stephanie Forrest},
            pdftitle={Subtypes for Free!},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{natbib}
\bibliographystyle{plainnat}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\title{Subtypes for Free!}
\author{George Stelle and Stephanie Forrest}
\date{}

% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\begin{document}
\maketitle

\section{Introduction}\label{introduction}

Haskell's popularity is in large part due to its powerful type system,
which prevents a large class of runtime errors. Still, there is a class
of runtime errors which the type system does not prevent because some
functions assume a subtype of the declared argument type. For example,
the \texttt{head} function can fail at runtime if the argument nil.
Partial function errors of this sort can be prevented with appropriate
subtype inference. We present an approach to implementing generalized
algebraic data types (GADTs) using rank-n types that supports subtype
inference to prevent these kinds of failures.

\section{Previous Work}\label{previous-work}

There is a vast literature on subtyping, from inheritance in
object-oriented languages and Liskov's substitution principle
{[}\cite{liskov1994behavioral}{]} to row and record polymorphism to
phantom types and generalized algebraic data types (GADTs)
{[}\cite{odersky2004overview, leroy2014ocaml}{]}. This work has enabled
many powerful type systems, but to our knowledge, none of these
subtyping schemes support inference over arbitrary subsets of the
constructors. For example, we are not aware of any subtyping scheme that
infers:

\begin{Shaded}
\begin{Highlighting}[]
   \NormalTok{null}\OtherTok{ nil ::} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

where \texttt{null} checks if a list is empty, \texttt{nil} is the empty
list, and \texttt{True} is a subtype of \texttt{Bool}. We present an
approach that enables this kind of inference.

\section{Approach}\label{approach}

As a simple example of the class of subtyping we investigate, consider a
typical Haskell inference, \texttt{True :: Bool}. Inferring
\texttt{Bool} as the type of \texttt{True} loses information about the
expression's possible values. Ideally, the type system would be as
precise as possible, so instead of always inferring \texttt{Bool}, it
could infer \texttt{True}, \texttt{False}, or \texttt{Bool}, where
\texttt{True} and \texttt{False} are \emph{subtypes} of \texttt{Bool},
i.e.~every value of type \texttt{True} is also of type \texttt{Bool}.
This level of precision can prevent certain types of run-time errors by
replacing partial functions with their total counterparts.

We use Scott encoding of algebraic data types, along with the Glasgow
Haskell Compiler's (GHC's) type inference with rank-n polymorphism to
achieve a general form of subtype polymorphism. TODO: More precise.
Scott encodings implement algebraic data types by encoding their own
\texttt{case} deconstruction using lambda expressions. By wrapping the
Scott encodings in a \texttt{newtype}, and then carefully constraining
the types, we can define types that represent arbitrary subsets of the
constructors. This approach allows us to typecheck the following
examples, among others:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{   true ::} \DataTypeTok{True}
   \NormalTok{and true}\OtherTok{ false ::} \DataTypeTok{False}
\OtherTok{   head ::} \DataTypeTok{Cons} \NormalTok{a }\OtherTok{->} \NormalTok{a}
\OtherTok{   fromJust ::} \DataTypeTok{Just} \NormalTok{a }\OtherTok{->} \NormalTok{a}
   \NormalTok{null}\OtherTok{ nil ::} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

\section{Preventing Runtime Failures with Subtype
Inferencing}\label{preventing-runtime-failures-with-subtype-inferencing}

We illustrate our approach by defining a total version of
\texttt{fromJust} from the Haskell standard library.

Define a \texttt{Maybe} type as a replacement for Haskell's
\texttt{data Maybe a = Just a \textbar{} Nothing}. The Scott encoding
for \texttt{Maybe} takes two case arguments, the first, of type
\texttt{n}, corresponding to \texttt{nothing}, so it has no parameters,
and the second, of type \texttt{a -\textgreater{} j}, corresponding to
\texttt{just a}, so it has one parameter of type \texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{newtype} \DataTypeTok{Maybe'} \NormalTok{a n j m }\FunctionTok{=} \DataTypeTok{Maybe} \NormalTok{(n }\OtherTok{->} \NormalTok{(a }\OtherTok{->} \NormalTok{j) }\OtherTok{->} \NormalTok{m)}
  \KeywordTok{type} \DataTypeTok{Maybe} \NormalTok{a }\FunctionTok{=} \NormalTok{forall m}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a m m m }
  \KeywordTok{type} \DataTypeTok{Just} \NormalTok{a }\FunctionTok{=} \NormalTok{forall n j}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a n j j}
\OtherTok{  just ::} \NormalTok{a }\OtherTok{->} \DataTypeTok{Just} \NormalTok{a}
  \NormalTok{just a }\FunctionTok{=} \DataTypeTok{Maybe} \FunctionTok{$} \NormalTok{\textbackslash{}n j }\OtherTok{->} \NormalTok{j a}
  \KeywordTok{type} \DataTypeTok{Nothing} \FunctionTok{=} \NormalTok{forall a n j}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a n j n}
\OtherTok{  nothing ::} \DataTypeTok{Nothing}
  \NormalTok{nothing }\FunctionTok{=} \DataTypeTok{Maybe} \FunctionTok{$} \NormalTok{\textbackslash{}n j }\OtherTok{->} \NormalTok{n}
\end{Highlighting}
\end{Shaded}

For the `Maybe' type, similar to the \texttt{maybe} function from
Haskell's \texttt{Data.Maybe}, we don't know whether we have a value of
type \texttt{Just} or a value of type \texttt{Nothing}, so we must
ensure that both cases return the same type. But, if the compiler can
infer that the value is of type \texttt{Just}, we don't care what the
\texttt{n} type is, and only constrain the return type to be the same as
the \texttt{Just} case \texttt{j}.

With that in mind, we now write the total function \texttt{fromJust}. As
a sanity check, we define the type \texttt{Bottom} which has no values
and observe that the function never typechecks \texttt{fromJust} applied
to a type that includes \texttt{Nothing}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{  fromJust ::} \DataTypeTok{Just} \NormalTok{a }\OtherTok{->} \NormalTok{a}
  \NormalTok{fromJust (}\DataTypeTok{Maybe} \NormalTok{j) }\FunctionTok{=} \NormalTok{j bottom }\FunctionTok{$} \NormalTok{\textbackslash{}a}\OtherTok{->}\NormalTok{a}

  \KeywordTok{data} \DataTypeTok{Bottom}
  \NormalTok{bottom }\FunctionTok{=} \NormalTok{error }\StringTok{"impossible"}\OtherTok{ ::} \DataTypeTok{Bottom}
\end{Highlighting}
\end{Shaded}

By contrast, the partial function \texttt{partialFromJust}, identical to
that defined in the Haskell standard library, allows runtime failures.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{  partialFromJust ::} \DataTypeTok{Maybe} \NormalTok{a }\OtherTok{->} \NormalTok{a}
  \NormalTok{partialFromJust (}\DataTypeTok{Maybe} \NormalTok{m) }\FunctionTok{=} \NormalTok{m (error }\StringTok{"partialFromJust Nothing"}\NormalTok{) }\FunctionTok{$} \NormalTok{\textbackslash{}a}\OtherTok{->}\NormalTok{a }
\end{Highlighting}
\end{Shaded}

More elaborate examples, including recursive types, GADTs, and total
versions of \texttt{head} and \texttt{tail}, are implemented and
available at \url{http://cs.unm.edu/~stelleg/scott/}.

We are currently formalizing and verifying this approach using
parametricity. {[}\cite{wadler1989theorems}{]}.

\section{Conclusion}\label{conclusion}

Powerful forms of subtyping such as we have shown here could help
Haskell programs avoid some classes of run-time errors, by defining
total versions of existing partial functions. As the Haskell language
continues to mature and gain wider acceptance in the programming
community, automatic prevention of runtime errors also becomes more
important.

\bibliography{subtypes}

\end{document}
