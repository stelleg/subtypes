\documentclass[]{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={Subtypes for Free!},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{natbib}
\bibliographystyle{plainnat}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\title{Subtypes for Free!}
\author{George Stelle \\ University of New Mexico \\ stelleg@cs.unm.edu}
\date{}

% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\begin{document}
\maketitle

\section{Introduction}\label{introduction}

Haskell's popularity is in large part due to its powerful type system,
which prevents a large class of runtime errors. Unfortunately, it
doesn't prevent some runtime errors caused by partial functions which
are only defined for subtype of their input type. For example, the
\texttt{head} function will fail at runtime if the argument is the empty
list. Some errors of this sort can be prevented with appropriate subtype
inference. We present an approach to implementing algebraic data types
(ADTs) using Scott encodings and rank-n types that supports subtype
inference to prevent these kinds of failures.

\section{Previous Work}\label{previous-work}

With a few exceptions, work on subtypes has focused on defining a
subtype heirarchy the entire type space
{[}\cite{mitchell1991type, liskov1994behavioral}{]}. Our work is less
ambitious in scope: we only define subtypes within the type of an ADT.
Similar in spirit to Scala's \texttt{case class} constructs
{[}\cite{odersky2004overview}{]}, our approach enables type inference
over arbitrary subsets of the constructors of an ADT.

Like our technique, generalized algebraic data types (GADTs) use
parametric polymorphism to implement subtypes of ADTs
{[}\cite{fluet2006phantom}{]}. Indeed, the connection is deeper: for the
canonical GADT example of a simple language with booleans and integers,
one can implement a type-safe evaluator using our approach or GADTs. We
suspect that there is significant overlap between the approaches, and
are working on proving that this is the case.

We address the following gap in the literature: we are not aware of any
type system that infers

\begin{Shaded}
\begin{Highlighting}[]
   \NormalTok{null}\OtherTok{ nil ::} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

where \texttt{null} checks if a list is empty, \texttt{nil} is the empty
list, and \texttt{True} is a subtype of \texttt{Bool} \footnote{Scala's
  \texttt{case class} construct is capable of something similar, but
  only with methods, e.g. \texttt{Nil().nil : True}.}.

\section{Approach}\label{approach}

Using parametric polymorphism to define subtypes is at the core of our
approach. Consider the Church/Scott boolean functions
\texttt{true t f = t} and \texttt{false t f = f}. \texttt{true} is of
type \texttt{a -\textgreater{} b -\textgreater{} a}, and \texttt{false}
is of type \texttt{a -\textgreater{} b -\textgreater{} b}. If we unify
the two types, we get \texttt{a -\textgreater{} a -\textgreater{} a}. If
we alias the types to \texttt{True}, \texttt{False,} and \texttt{Bool},
respectively, \texttt{True} and \texttt{False} are subtypes of
\texttt{Bool}, i.e.~every value of type \texttt{True} is also of type
\texttt{Bool}.

To implement this approach for any ADT, we use Scott encodings along
with the Glasgow Haskell Compiler's (GHC's) rank-n type inference. Scott
encodings implement ADTs by encoding their own \texttt{case}
deconstruction using lambda expressions, like the boolean case above. By
wrapping the Scott encodings in a \texttt{newtype}, and then carefully
constraining the types, we can define types that represent arbitrary
subsets of an ADT's constructors. This allows us to typecheck the
following examples, among others:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{   true ::} \DataTypeTok{True}
   \NormalTok{true }\OtherTok{`and` false ::} \DataTypeTok{False}
\OtherTok{   head ::} \DataTypeTok{Cons} \NormalTok{a }\OtherTok{->} \NormalTok{a}
\OtherTok{   fromJust ::} \DataTypeTok{Just} \NormalTok{a }\OtherTok{->} \NormalTok{a}
   \NormalTok{null}\OtherTok{ nil ::} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

We are currently formalizing and verifying our approach using
parametricity {[}\cite{wadler1989theorems}{]}.

\section{Preventing Runtime Failures with
Subtypes}\label{preventing-runtime-failures-with-subtypes}

We illustrate our approach by defining a total version of
\texttt{fromJust} from the Haskell standard library.

We define a \texttt{Maybe} type as a replacement for Haskell's
\texttt{data Maybe a = Just a \textbar{} Nothing}. The Scott encoding
for \texttt{Maybe} takes two case arguments. The first, of type
\texttt{n}, corresponds to \texttt{nothing}, so it has no parameters,
and the second, of type \texttt{a -\textgreater{} j}, corresponds to
\texttt{just a}, so it has one parameter of type \texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{newtype} \DataTypeTok{Maybe'} \NormalTok{a n j m }\FunctionTok{=} \DataTypeTok{Maybe} \NormalTok{(n }\OtherTok{->} \NormalTok{(a }\OtherTok{->} \NormalTok{j) }\OtherTok{->} \NormalTok{m)}
  \KeywordTok{type} \DataTypeTok{Maybe} \NormalTok{a }\FunctionTok{=} \NormalTok{forall m}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a m m m }
  \KeywordTok{type} \DataTypeTok{Just} \NormalTok{a }\FunctionTok{=} \NormalTok{forall n j}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a n j j}
\OtherTok{  just ::} \NormalTok{a }\OtherTok{->} \DataTypeTok{Just} \NormalTok{a}
  \NormalTok{just a }\FunctionTok{=} \DataTypeTok{Maybe} \FunctionTok{$} \NormalTok{\textbackslash{}n j }\OtherTok{->} \NormalTok{j a}
  \KeywordTok{type} \DataTypeTok{Nothing} \FunctionTok{=} \NormalTok{forall a n j}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a n j n}
\OtherTok{  nothing ::} \DataTypeTok{Nothing}
  \NormalTok{nothing }\FunctionTok{=} \DataTypeTok{Maybe} \FunctionTok{$} \NormalTok{\textbackslash{}n j }\OtherTok{->} \NormalTok{n}
\end{Highlighting}
\end{Shaded}

For the \texttt{Maybe} type above, like standard case deconstruction in
Haskell, we don't know whether we have a value of type \texttt{Just a}
or a value of type \texttt{Nothing}, so we must ensure that both cases
return the same type. But, if the compiler can infer that the value is
of type \texttt{Just a}, we don't care what the \texttt{n} type is, and
only constrain the return type to be the same as the \texttt{Just} case,
\texttt{j}.

With that in mind, we now define our total function \texttt{fromJust}.
As a sanity check, we define the type \texttt{Bottom} which has no
values and observe that the function never typechecks \texttt{fromJust}
applied to a type that includes \texttt{Nothing}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{  fromJust ::} \DataTypeTok{Just} \NormalTok{a }\OtherTok{->} \NormalTok{a}
  \NormalTok{fromJust (}\DataTypeTok{Maybe} \NormalTok{j) }\FunctionTok{=} \NormalTok{j bottom }\FunctionTok{$} \NormalTok{\textbackslash{}a}\OtherTok{->}\NormalTok{a}

  \KeywordTok{data} \DataTypeTok{Bottom}
  \NormalTok{bottom }\FunctionTok{=}\OtherTok{ undefined ::} \DataTypeTok{Bottom}
\end{Highlighting}
\end{Shaded}

By contrast, the partial function \texttt{partialFromJust}, identical to
that defined in the Haskell standard library, allows runtime failures.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{  partialFromJust ::} \DataTypeTok{Maybe} \NormalTok{a }\OtherTok{->} \NormalTok{a}
  \NormalTok{partialFromJust (}\DataTypeTok{Maybe} \NormalTok{m) }\FunctionTok{=} \NormalTok{m (error }\StringTok{"partialFromJust Nothing"}\NormalTok{) }\FunctionTok{$} \NormalTok{\textbackslash{}a}\OtherTok{->}\NormalTok{a }
\end{Highlighting}
\end{Shaded}

More elaborate examples are implemented and available at
\url{http://cs.unm.edu/~stelleg/scott/}.

\section{Conclusion}\label{conclusion}

As the Haskell language continues to mature and gain wider acceptance in
the programming community, automatic prevention of runtime errors
becomes even more valuable. The restricted form of subtyping shown here
could help Haskell programs avoid some classes of run-time errors by
defining total versions of existing partial functions.

\bibliography{subtypes}

\end{document}
