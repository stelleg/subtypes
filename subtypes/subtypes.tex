\documentclass[]{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={George Stelle and Stephanie Forrest},
            pdftitle={Subtypes for Free!},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\usepackage[normalem]{ulem}
% avoid problems with \sout in headers with hyperref:
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\title{Subtypes for Free!}
\author{George Stelle and Stephanie Forrest}
\date{}

% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\begin{document}
\maketitle

\section{Motivation}\label{motivation}

It would be nice if a type system could be as precise as possible to
restrict what a value will be. In Haskell, for example, the type
\texttt{Bool} ensures a value will either be \texttt{True} or
\texttt{False}. What we want is the type system to be precise when
possible, so instead of always inferring \texttt{Bool}, it could infer
\texttt{True}, \texttt{False}, or \texttt{Bool}, where \texttt{True} and
\texttt{False} are \emph{subtypes} of \texttt{Bool}, i.e.~every value of
type \texttt{True} is also of type \texttt{Bool}. This preciseness can
ensure the prevention of run-time errors by removing partial functions,
like \texttt{head} and \texttt{tail}.

\section{Existing Approaches}\label{existing-approaches}

There is a significant literature on subtyping, mostly in the context of
object-oriented (OO) languages. Indeed, subtyping in languages that
combine OO features with functional features implement subtypes using
objects \cite{odersky2004overview, leroy2014ocaml}.

Generalized algebraic data types (GADTs) enable a limited form of
subtyping as well \cite{fluet2006phantom}. For example, in the canonical
example of a simple language with booleans and integers,
\texttt{Expr Int} are distinct from \texttt{Expr Bool}, while both are
subtypes of \texttt{Expr a}.

For both the OO and the GADT approaches, we are not aware of any capable
of inferring:

\begin{Shaded}
\begin{Highlighting}[]
   \NormalTok{null}\OtherTok{ nil ::} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

where \texttt{null} checks if a list is empty and \texttt{nil} is the
empty list.

\section{Our Approach}\label{our-approach}

We use Scott encoding of algebraic data types, along with the Glasgow
Haskell Compiler's (GHC's) type inference, to achieve a very general
form of subtype polymorphism. We show how GHC can take advantage of this
approach without modification by \sout{abusing} taking full advantage of
rank-n types.

Scott encodings are implementations of algebraic data types that encode
their own \texttt{case} destruction using lambda expressions. Our
primary insight is that by wrapping the Scott encodings in a
\texttt{newtype}, and then carefully constraining the types, we can
define types that represent arbitrary subsets of the constructors.

This allows us to type the following examples, among others:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{   true ::} \DataTypeTok{True}
   \NormalTok{and true}\OtherTok{ false ::} \DataTypeTok{False}
\OtherTok{   head ::} \DataTypeTok{Cons} \NormalTok{a }\OtherTok{->} \NormalTok{a}
\OtherTok{   fromJust ::} \DataTypeTok{Just} \NormalTok{a }\OtherTok{->} \NormalTok{a}
   \NormalTok{null}\OtherTok{ nil ::} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

\section{An Example}\label{an-example}

One application of subtyping is to runtime failures. Here we show how to
use our approach to define a total version of \texttt{fromJust} from the
Haskell standard library.

To achieve this, we define a \texttt{Maybe} type as a replacement for
Haskell's \texttt{data Maybe a = Just a \textbar{} Nothing}. The Scott
encoding for \texttt{Maybe} takes two \emph{case} arguments, the first,
of type \texttt{n}, corresponding to \texttt{nothing}, so it has no
parameters, and the second, of type \texttt{a -\textgreater{} j},
corresponding to \texttt{just a}, so it has one parameter of type
\texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{newtype} \DataTypeTok{Maybe'} \NormalTok{a n j m }\FunctionTok{=} \DataTypeTok{Maybe} \NormalTok{(n }\OtherTok{->} \NormalTok{(a }\OtherTok{->} \NormalTok{j) }\OtherTok{->} \NormalTok{m)}
  \KeywordTok{type} \DataTypeTok{Maybe} \NormalTok{a }\FunctionTok{=} \NormalTok{forall m}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a m m m }
  \KeywordTok{type} \DataTypeTok{Just} \NormalTok{a }\FunctionTok{=} \NormalTok{forall n j}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a n j j}
\OtherTok{  just ::} \NormalTok{a }\OtherTok{->} \DataTypeTok{Just} \NormalTok{a}
  \NormalTok{just a }\FunctionTok{=} \DataTypeTok{Maybe} \FunctionTok{$} \NormalTok{\textbackslash{}n j }\OtherTok{->} \NormalTok{j a}
  \KeywordTok{type} \DataTypeTok{Nothing} \FunctionTok{=} \NormalTok{forall a n j}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a n j n}
\OtherTok{  nothing ::} \DataTypeTok{Nothing}
  \NormalTok{nothing }\FunctionTok{=} \DataTypeTok{Maybe} \FunctionTok{$} \NormalTok{\textbackslash{}n j }\OtherTok{->} \NormalTok{n}
\end{Highlighting}
\end{Shaded}

Our \texttt{Maybe} type is analogous to the standard \texttt{Data.Maybe}
type in Haskell. In this case, similar to the \texttt{maybe} function
from \texttt{Data.Maybe}, we don't know whether we have a value of type
\texttt{Just} or a value of type \texttt{Nothing}, so we must ensure
that the two cases return the same type. But if the compiler can infer
that the value is of type \texttt{Just}, we don't care what the
\texttt{n} cases type is, and only constrain the return type to be the
same as the \texttt{Just} case \texttt{j}.

With that in mind, we can write our total \texttt{fromJust}, using a
\texttt{Bottom} type with no values to convince ourselves that our
function will never typecheck \texttt{fromJust} applied to a type that
includes \texttt{Nothing}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{  fromJust ::} \DataTypeTok{Just} \NormalTok{a }\OtherTok{->} \NormalTok{a}
  \NormalTok{fromJust (}\DataTypeTok{Maybe} \NormalTok{j) }\FunctionTok{=} \NormalTok{j bottom }\FunctionTok{$} \NormalTok{\textbackslash{}a}\OtherTok{->}\NormalTok{a}

  \KeywordTok{data} \DataTypeTok{Bottom}
  \NormalTok{bottom }\FunctionTok{=} \NormalTok{error }\StringTok{"impossible"}\OtherTok{ ::} \DataTypeTok{Bottom}
\end{Highlighting}
\end{Shaded}

We can still define the partial version of \texttt{fromJust}, which like
the one from the Haskell standard library, allows runtime failure.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{  partialFromJust ::} \DataTypeTok{Maybe} \NormalTok{a }\OtherTok{->} \NormalTok{a}
  \NormalTok{partialFromJust (}\DataTypeTok{Maybe} \NormalTok{m) }\FunctionTok{=} \NormalTok{m (error }\StringTok{"partialFromJust Nothing"}\NormalTok{) }\FunctionTok{$} \NormalTok{\textbackslash{}a}\OtherTok{->}\NormalTok{a }
\end{Highlighting}
\end{Shaded}

We have implemented more sophisticated examples, including recursive
types, GADTs, and total versions of \texttt{head} and \texttt{tail},
available at \url{http://cs.unm.edu/~stelleg/scott/}.

\section{Conclusion}\label{conclusion}

We have shown how to attain powerful form of subtyping in Haskell using
basic extensions. The resulting subtypes allow us to define total
versions of existing partial functions, preventing runtime errors. We
are currently working on formalizing and verifying this approach using
parametricity \cite{wadler1989theorems}.

\end{document}
