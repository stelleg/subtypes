\documentclass[]{article}
\usepackage[a4paper, margin=1in]{geometry}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={George Stelle and Stephanie Forrest},
            pdftitle={Subtypes for Free!},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{natbib}
\bibliographystyle{plainnat}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
\newcommand{\NormalTok}[1]{{#1}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}

\title{Subtypes for Free!}
\author{George Stelle and Stephanie Forrest}
\date{}

% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\begin{document}
\maketitle

\section{Introduction}\label{introduction}

Haskell's popularity is in large part thanks to its powerful type system
which prevents a large class of runtime errors. Still, there are a class
of function that expect only a subtype of their declared type, e.g.
\texttt{head}, that can fail at runtime. We present an approach to
subtyping GADTs that allows us to define versions of these functions
that cannot fail.

\section{Existing Approaches}\label{existing-approaches}

There is much too broad a literature on subtyping to cover here, from
inheritance in object oriented languages and Liskov's substitution
principle \cite{liskov1994behavioral} to row and record polymorphism to
phantom types and generalized algebraic data types (GADTs)
{[}\cite{odersky2004overview,
leroy2014ocaml}{]}. We instead focus on what these techniques
\emph{can't} do. Namely, as far as we are aware, \emph{no existing
subtyping scheme can, for a given GADT, define \textbf{and infer} types
for arbitrary subsets of the constructors}. For example, we are not
aware of any subtyping scheme able to infer that:

\begin{Shaded}
\begin{Highlighting}[]
   \NormalTok{null}\OtherTok{ nil ::} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

where \texttt{null} checks if a list is empty, \texttt{nil} is the empty
list, and \texttt{True} is the subtype of \texttt{Bool} containing only
the value \texttt{true} (modulo program equivalence). We present an
approach that enables this kind of inference.

\section{Our Approach}\label{our-approach}

By inferring \texttt{Bool} as the type of \texttt{True}, we are losing
precision in the type system about what the value can be. What we would
like is for the type system to be precise when possible, so instead of
always inferring \texttt{Bool}, it could infer \texttt{True},
\texttt{False}, or \texttt{Bool}, where \texttt{True} and \texttt{False}
are \emph{subtypes} of \texttt{Bool}, i.e.~every value of type
\texttt{True} is also of type \texttt{Bool}. We present an approach that
enables this class of inference, and show how it can prevent run-time
errors by replacing partial functions with their total counterparts,
e.g. \texttt{head} and \texttt{tail}.

We use Scott encoding of algebraic data types, along with the Glasgow
Haskell Compiler's (GHC's) type inference with rank-n polymorphism to
achieve a very general form of subtype polymorphism.

Scott encodings are implementations of algebraic data types that encode
their own \texttt{case} destruction using lambda expressions. Our
primary insight is that by wrapping the Scott encodings in a
\texttt{newtype}, and then carefully constraining the types, we can
define types that represent arbitrary subsets of the constructors.

This allows us to type the following examples, among others:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{   true ::} \DataTypeTok{True}
   \NormalTok{and true}\OtherTok{ false ::} \DataTypeTok{False}
\OtherTok{   head ::} \DataTypeTok{Cons} \NormalTok{a }\OtherTok{->} \NormalTok{a}
\OtherTok{   fromJust ::} \DataTypeTok{Just} \NormalTok{a }\OtherTok{->} \NormalTok{a}
   \NormalTok{null}\OtherTok{ nil ::} \DataTypeTok{True}
\end{Highlighting}
\end{Shaded}

\section{An Example}\label{an-example}

One application of subtyping is to prevent runtime failures. Here we
show how to use our approach to define a total version of
\texttt{fromJust} from the Haskell standard library.

To achieve this, we define a \texttt{Maybe} type as a replacement for
Haskell's \texttt{data Maybe a = Just a \textbar{} Nothing}. The Scott
encoding for \texttt{Maybe} takes two \emph{case} arguments, the first,
of type \texttt{n}, corresponding to \texttt{nothing}, so it has no
parameters, and the second, of type \texttt{a -\textgreater{} j},
corresponding to \texttt{just a}, so it has one parameter of type
\texttt{a}.

\begin{Shaded}
\begin{Highlighting}[]
  \KeywordTok{newtype} \DataTypeTok{Maybe'} \NormalTok{a n j m }\FunctionTok{=} \DataTypeTok{Maybe} \NormalTok{(n }\OtherTok{->} \NormalTok{(a }\OtherTok{->} \NormalTok{j) }\OtherTok{->} \NormalTok{m)}
  \KeywordTok{type} \DataTypeTok{Maybe} \NormalTok{a }\FunctionTok{=} \NormalTok{forall m}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a m m m }
  \KeywordTok{type} \DataTypeTok{Just} \NormalTok{a }\FunctionTok{=} \NormalTok{forall n j}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a n j j}
\OtherTok{  just ::} \NormalTok{a }\OtherTok{->} \DataTypeTok{Just} \NormalTok{a}
  \NormalTok{just a }\FunctionTok{=} \DataTypeTok{Maybe} \FunctionTok{$} \NormalTok{\textbackslash{}n j }\OtherTok{->} \NormalTok{j a}
  \KeywordTok{type} \DataTypeTok{Nothing} \FunctionTok{=} \NormalTok{forall a n j}\FunctionTok{.} \DataTypeTok{Maybe'} \NormalTok{a n j n}
\OtherTok{  nothing ::} \DataTypeTok{Nothing}
  \NormalTok{nothing }\FunctionTok{=} \DataTypeTok{Maybe} \FunctionTok{$} \NormalTok{\textbackslash{}n j }\OtherTok{->} \NormalTok{n}
\end{Highlighting}
\end{Shaded}

Our \texttt{Maybe} type is analogous to the standard \texttt{Data.Maybe}
type in Haskell. In this case, similar to the \texttt{maybe} function
from \texttt{Data.Maybe}, we don't know whether we have a value of type
\texttt{Just} or a value of type \texttt{Nothing}, so we must ensure
that the two cases return the same type. But if the compiler can infer
that the value is of type \texttt{Just}, we don't care what the
\texttt{n} type is, and only constrain the return type to be the same as
the \texttt{Just} case \texttt{j}.

With that in mind, we can write our total \texttt{fromJust}, using a
\texttt{Bottom} type with no values to convince ourselves that our
function will never typecheck \texttt{fromJust} applied to a type that
includes \texttt{Nothing}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{  fromJust ::} \DataTypeTok{Just} \NormalTok{a }\OtherTok{->} \NormalTok{a}
  \NormalTok{fromJust (}\DataTypeTok{Maybe} \NormalTok{j) }\FunctionTok{=} \NormalTok{j bottom }\FunctionTok{$} \NormalTok{\textbackslash{}a}\OtherTok{->}\NormalTok{a}

  \KeywordTok{data} \DataTypeTok{Bottom}
  \NormalTok{bottom }\FunctionTok{=} \NormalTok{error }\StringTok{"impossible"}\OtherTok{ ::} \DataTypeTok{Bottom}
\end{Highlighting}
\end{Shaded}

We can still define the partial version of \texttt{fromJust}, which like
the one from the Haskell standard library, allows runtime failure.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{  partialFromJust ::} \DataTypeTok{Maybe} \NormalTok{a }\OtherTok{->} \NormalTok{a}
  \NormalTok{partialFromJust (}\DataTypeTok{Maybe} \NormalTok{m) }\FunctionTok{=} \NormalTok{m (error }\StringTok{"partialFromJust Nothing"}\NormalTok{) }\FunctionTok{$} \NormalTok{\textbackslash{}a}\OtherTok{->}\NormalTok{a }
\end{Highlighting}
\end{Shaded}

We have implemented more sophisticated examples, including recursive
types, GADTs, and total versions of \texttt{head} and \texttt{tail},
available at \url{http://cs.unm.edu/~stelleg/scott/}.

\section{Conclusion}\label{conclusion}

We have shown how to attain powerful form of subtyping in Haskell using
basic extensions. The resulting subtypes allow us to define total
versions of existing partial functions, preventing runtime errors. We
are currently working on formalizing and verifying this approach using
parametricity {[}\cite{wadler1989theorems}{]}.

\bibliography{subtypes}

\end{document}
